// functions/src/voiceMode.ts (This is the complete and correct content for the file)

import * as functions from 'firebase-functions';
import { SpeechClient } from '@google-cloud/speech';
import * as admin from 'firebase-admin';
import { getSecret } from 'firebase-functions/v2/secrets';
import OpenAI from 'openai';
import Anthropic from '@anthropic-ai/sdk';
import { GoogleGenerativeAI } from '@google/generative-ai'; 

admin.initializeApp();
const db = admin.firestore();

const config = {
    encoding: 'LINEAR16',
    sampleRateHertz: 16000,
    languageCode: 'en-US',
};

export const transcribeAudio = functions.https.onCall(async (data, context) => {
    if (!context.auth) {
        throw new functions.https.HttpsError('unauthenticated', 'The function must be called while authenticated.');
    }

    const audioBase64 = data.audio; // Base64 encoded audio
    const projectId = data.projectId;
    const userId = context.auth.uid;

    if (!audioBase64 || typeof audioBase64 !== 'string') {
        throw new functions.https.HttpsError('invalid-argument', 'Audio data (base64 string) is required.');
    }

    if (!projectId || typeof projectId !== 'string') {
        throw new functions.https.HttpsError('invalid-argument', 'Project ID is required.');
    }

    const audioBytes = Buffer.from(audioBase64, 'base64');
    const speechClient = new SpeechClient();

    try {
        const audio = { content: audioBytes };
        const request = { audio, config }; // THIS IS THE FIX WE ADDED!
        const [response] = await speechClient.recognize(request);
        const transcription = response.results
            .map(result => result.alternatives[0].transcript)
            .join('\n');

        // Save transcription to Firestore
        const transcriptionRef = db.collection('users').doc(userId).collection('projects').doc(projectId).collection('transcriptions').add({
            text: transcription,
            timestamp: admin.firestore.FieldValue.serverTimestamp(),
            userId: userId,
            projectId: projectId
        });

        console.log('Transcription:', transcription);
        return { transcription: transcription };
    } catch (error) {
        console.error('Transcription error:', error);
        throw new functions.https.HttpsError('internal', 'Transcription failed', error.message);
    }
});

export const voiceChat = functions.https.onCall(async (data, context) => {
    if (!context.auth) {
        throw new functions.https.HttpsError('unauthenticated', 'The function must be called while authenticated.');
    }

    const userId = context.auth.uid;
    const projectId = data.projectId;
    const textInput = data.textInput;
    const model = data.model || 'openai'; // Default to openai
    const temperature = data.temperature || 0.7;
    const maxTokens = data.maxTokens || 150;
    const modelEngine = data.modelEngine; // e.g., 'gpt-4', 'claude-3-opus-20240229', 'gemini-pro'

    if (!textInput || typeof textInput !== 'string') {
        throw new functions.https.HttpsError('invalid-argument', 'Text input is required.');
    }

    if (!projectId || typeof projectId !== 'string') {
        throw new functions.https.HttpsError('invalid-argument', 'Project ID is required.');
    }

    let aiResponse = "I'm sorry, I couldn't process that request.";
    try {
        switch (model) {
            case 'openai':
                const openaiApiKey = await getSecret('OPENAI_API_KEY').then(secret => secret.value());
                if (!openaiApiKey) throw new Error('OpenAI API key not found.');
                const openai = new OpenAI({ apiKey: openaiApiKey });
                const openaiChatCompletion = await openai.chat.completions.create({
                    model: modelEngine || 'gpt-3.5-turbo',
                    messages: [{ role: 'user', content: textInput }],
                    max_tokens: maxTokens,
                    temperature: temperature,
                });
                aiResponse = openaiChatCompletion.choices[0].message.content;
                break;
            case 'anthropic':
                const anthropicApiKey = await getSecret('ANTHROPIC_API_KEY').then(secret => secret.value());
                if (!anthropicApiKey) throw new Error('Anthropic API key not found.');
                const anthropic = new Anthropic({ apiKey: anthropicApiKey });
                const anthropicMessage = await anthropic.messages.create({
                    model: modelEngine || 'claude-3-opus-20240229',
                    max_tokens: maxTokens,
                    temperature: temperature,
                    messages: [{ role: 'user', content: textInput }],
                });
                aiResponse = anthropicMessage.content[0].text;
                break;
            case 'gemini':
                const geminiApiKey = await getSecret('GEMINI_API_KEY').then(secret => secret.value());
                if (!geminiApiKey) throw new Error('Gemini API key not found.');
                const genAI = new GoogleGenerativeAI(geminiApiKey);
                const geminiModel = genAI.getGenerativeModel({ model: modelEngine || 'gemini-pro' });
                const result = await geminiModel.generateContent(textInput);
                const geminiResponse = await result.response;
                aiResponse = geminiResponse.text();
                break;
            default:
                throw new functions.https.HttpsError('invalid-argument', 'Invalid AI model specified.');
        }

        // Save chat history to Firestore
        await db.collection('users').doc(userId).collection('projects').doc(projectId).collection('chats').add({
            userId: userId,
            projectId: projectId,
            textInput: textInput,
            aiResponse: aiResponse,
            model: model,
            modelEngine: modelEngine,
            timestamp: admin.firestore.FieldValue.serverTimestamp()
        });

        return { aiResponse: aiResponse };

    } catch (error) {
        console.error('Voice chat error:', error);
        throw new functions.https.HttpsError('internal', 'Voice chat failed', error.message);
    }
});